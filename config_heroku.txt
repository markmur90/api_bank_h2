‚úÖ 2. Variables de entorno necesarias en Heroku

Aqu√≠ tienes lo esencial:
heroku config:set NOMBRE=valor

heroku config:set DJANGO_SECRET_KEY=clave_supersecreta_en_produccion
heroku config:set DJANGO_DEBUG=False
heroku config:set DJANGO_ALLOWED_HOSTS=*.herokuapp.com

heroku config:set DB_CLIENT_ID=tu-client-id-heroku
heroku config:set DB_CLIENT_SECRET=tu-client-secret-heroku
heroku config:set DB_TOKEN_URL=https://simulator-api.db.com:443/gw/dbapi/token
heroku config:set DB_AUTH_URL=https://simulator-api.db.com:443/gw/dbapi/authorize
heroku config:set DB_API_URL=https://simulator-api.db.com:443/gw/dbapi/paymentInitiation/payments/v1/sepaCreditTransfer
heroku config:set DB_SCOPE=sepa_credit_transfers
heroku config:set API_ORIGIN=https://simulator-api.db.com
heroku config:set TIMEOUT_REQUEST=20

heroku config:set PRIVATE_KEY_PATH=keys/private_key.pem
heroku config:set PRIVATE_KEY_KID=clave-jwt-heroku

heroku config:set OAUTH2_REDIRECT_URI=https://<TU_APP>.herokuapp.com/oauth2/callback/

    Sustituye <TU_APP> por el nombre real de tu aplicaci√≥n en Heroku.

‚úÖ 3. Configurar y desplegar tu app Django en Heroku
A. Inicializar el repositorio (si no lo hiciste a√∫n):

git init
heroku create nombre-heroku

B. Agregar buildpacks (si usas WeasyPrint):

heroku buildpacks:add --index 1 https://github.com/miketheman/heroku-buildpack-apt

C. Push al deploy:

git add .
git commit -m "deploy inicial"
git push heroku master

D. Migraciones y superusuario (opcional)

heroku run python manage.py migrate
heroku run python manage.py createsuperuser

‚úÖ 4. Consideraciones especiales para Deutsche Bank en Heroku

    ‚úÖ Registra el redirect_uri como:
    https://<TU_APP>.herokuapp.com/oauth2/callback/

    ‚úÖ Verifica que la clave privada (keys/private_key.pem) est√© cargada. Usa git o mejor a√∫n, almac√©nala en config vars y reconstr√∫yela en tiempo de arranque.






üîß CAMBIOS QUE SE APLICAR√ÅN
1. Centralizaci√≥n de configuraci√≥n
    Cargar autom√°ticamente las variables sensibles y rutas desde config_master.py o el .env generado (source destinos.env).
    Eliminar duplicados de valores como PROJECT_DIR, LOG_DIR, INTERFAZ, DB_NAME, DB_USER, DB_PASS, etc.

2. Normalizaci√≥n de rutas y variables
    Usar PROJECT_ROOT, LOG_FILE_SCRIPT, BACKUP_DIR, DB_NAME, TOR_PASS, etc. desde destinos.env.
    Reemplazar rutas absolutas y credenciales inline.

3. Uso uniforme de logs
    Todos los scripts escribir√°n en el master_run_YYYYMMDD_HHMMSS.log, pero cada uno adem√°s puede registrar eventos claves en su propio sublog si corresponde (operation.log, cron.log, etc.).

4. Modularizaci√≥n de helpers comunes
    NO ....Extraer funciones como log_info, log_error, ejecutar, etc., a un script scripts/helpers.sh para ser reutilizado en todos.

5. Protecci√≥n y control de errores
    Mejorar validaciones y detecci√≥n de fallos (if [[ -z "$VAR" ]], command -v, etc.).

6. Refuerzo de seguridad y portabilidad
    Separar secretos en .env, evitar duplicar contrase√±as PostgreSQL o claves Heroku/Njalla en scripts p√∫blicos.
    Validar existencia de claves, dependencias y rutas antes de ejecutar.

üì¶ ENTREGABLE FINAL

    Todos los scripts refactorizados profesionalmente, sin valores hardcodeados.
    Archivo destinos.env completo
    Un esquema .env.example base seguro y comentado para usar como plantilla.
    Un README.md de uso y despliegue r√°pido.